<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Bunker42</title>
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
    <meta name="apple-mobile-web-app-capable" content="yes" />
  </head>
  <body class="dark">
    <div id="unity-container" class="unity-desktop">
      <canvas id="unity-canvas"></canvas>
    </div>
    <div id="loading-cover" style="display:none;">
      <div id="unity-loading-bar">
        <div id="unity-logo"><img src="logo.png"></div>
        <div id="unity-progress-bar-empty" style="display: none;">
          <div id="unity-progress-bar-full"></div>
        </div>
        <div class="spinner"></div>
      </div>
    </div>
    <div id="unity-fullscreen-button" style="display: none;"></div>
    <script>
      const hideFullScreenButton = "";
      const buildUrl = "Build";
      const loaderUrl = buildUrl + "/Bunker-42-WebPage.loader.js";
      const config = {
        dataUrl: buildUrl + "/Bunker-42-WebPage.data",
        frameworkUrl: buildUrl + "/Bunker-42-WebPage.framework.js",
        codeUrl: buildUrl + "/Bunker-42-WebPage.wasm",
        streamingAssetsUrl: "StreamingAssets",
        companyName: "RealGamesStudio",
        productName: "Bunker42",
        productVersion: "0.1.0",
      };

      const container = document.querySelector("#unity-container");
      const canvas = document.querySelector("#unity-canvas");
      const loadingCover = document.querySelector("#loading-cover");
      const progressBarEmpty = document.querySelector("#unity-progress-bar-empty");
      const progressBarFull = document.querySelector("#unity-progress-bar-full");
      const fullscreenButton = document.querySelector("#unity-fullscreen-button");
      const spinner = document.querySelector('.spinner');

      const canFullscreen = (function() {
        for (const key of [
            'exitFullscreen',
            'webkitExitFullscreen',
            'webkitCancelFullScreen',
            'mozCancelFullScreen',
            'msExitFullscreen',
          ]) {
          if (key in document) {
            return true;
          }
        }
        return false;
      }());

      if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
        container.className = "unity-mobile";
        config.devicePixelRatio = 2;
      }
      loadingCover.style.display = "";

      const script = document.createElement("script");
      script.src = loaderUrl;
      script.onload = () => {
        createUnityInstance(canvas, config, (progress) => {
          spinner.style.display = "none";
          progressBarEmpty.style.display = "";
          progressBarFull.style.width = `${100 * progress}%`;
        }).then((unityInstance) => {
          loadingCover.style.display = "none";
          if (canFullscreen) {
            if (!hideFullScreenButton) {
              fullscreenButton.style.display = "";
            }
            fullscreenButton.onclick = () => {
              unityInstance.SetFullscreen(1);
            };
          }
          
          // Store Unity instance for keyboard detection
          window.unityInstance = unityInstance;
        }).catch((message) => {
          alert(message);
        });
      };
      document.body.appendChild(script);
    </script>
    <script>
      /**
       * Enhanced virtual keyboard handler for WebGL
       */
      (function() {
        // Configuration
        var config = {
            preferredBehavior: 'auto', // 'auto', 'push', or 'overlay'
            detectionThreshold: 100,   // Height difference threshold to detect keyboard
            inputSelector: 'input, textarea', // Selectors for input elements
            debug: false // Set to true for console log debugging
        };
        
        // State tracking
        var state = {
            initialHeight: 0,
            keyboardVisible: false,
            currentMode: 'none',
            measurementTimeout: null
        };
        
        // Initialize on page load
        function initialize() {
            if (config.debug) console.log('Initializing WebGL keyboard handler');
            
            // Save initial viewport height
            state.initialHeight = window.innerHeight;
            
            // Setup event listeners
            window.addEventListener('resize', handleResize);
            document.addEventListener('focusin', handleFocusIn);
            document.addEventListener('focusout', handleFocusOut);
            
            // Apply any stored behavior preference from URL parameters
            var urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('keyboard')) {
                config.preferredBehavior = urlParams.get('keyboard');
            }
        }
        
        // Handle window resize (potential keyboard appearance)
        function handleResize() {
            clearTimeout(state.measurementTimeout);
            state.measurementTimeout = setTimeout(measureKeyboard, 100);
        }
        
        // Handle input focus (keyboard likely to appear)
        function handleFocusIn(event) {
            // Only care about input elements
            if (!event.target.matches(config.inputSelector)) return;
            
            // Mark that we expect a keyboard
            state.keyboardVisible = true;
            
            // Measure with a slight delay to account for keyboard animation
            clearTimeout(state.measurementTimeout);
            state.measurementTimeout = setTimeout(measureKeyboard, 300);
        }
        
        // Handle input blur (keyboard likely to disappear)
        function handleFocusOut(event) {
            // Only care about input elements
            if (!event.target.matches(config.inputSelector)) return;
            
            // Mark that keyboard should be gone
            state.keyboardVisible = false;
            
            // Measure with a delay to account for keyboard animation
            clearTimeout(state.measurementTimeout);
            state.measurementTimeout = setTimeout(measureKeyboard, 300);
        }
        
        // Measure keyboard state and notify Unity
        function measureKeyboard() {
            // If initialHeight not set yet, set it now
            if (!state.initialHeight) {
                state.initialHeight = window.innerHeight;
                return;
            }
            
            var heightDiff = state.initialHeight - window.innerHeight;
            var keyboardDetected = heightDiff > config.detectionThreshold;
            
            // Determine keyboard mode
            var newMode = 'none';
            if (keyboardDetected) {
                // Force specific behavior if configured
                if (config.preferredBehavior === 'push') {
                    newMode = 'push';
                    document.body.classList.add('keyboard-push');
                    document.body.classList.remove('keyboard-overlay');
                } 
                else if (config.preferredBehavior === 'overlay') {
                    newMode = 'overlay';
                    document.body.classList.add('keyboard-overlay');
                    document.body.classList.remove('keyboard-push');
                }
                // Auto detection
                else {
                    if (heightDiff > 0) {
                        newMode = 'push';
                        document.body.classList.add('keyboard-push');
                        document.body.classList.remove('keyboard-overlay');
                    } else {
                        newMode = 'overlay';
                        document.body.classList.add('keyboard-overlay');
                        document.body.classList.remove('keyboard-push');
                    }
                }
                
                document.body.classList.add('keyboard-visible');
            } else {
                document.body.classList.remove('keyboard-visible');
                document.body.classList.remove('keyboard-push');
                document.body.classList.remove('keyboard-overlay');
            }
            
            // Only notify Unity if mode changed
            if (newMode !== state.currentMode) {
                state.currentMode = newMode;
                notifyUnity(newMode);
            }
        }
        
        // Notify Unity of keyboard state change
        function notifyUnity(mode) {
            if (config.debug) console.log('Keyboard mode: ' + mode);
            
            var unityInstance = window.unityInstance || null;
            if (unityInstance && unityInstance.SendMessage) {
                unityInstance.SendMessage('KeyboardManager', 'OnWebGLKeyboardState', mode);
            }
        }
        
        // Public API
        window.WebGLKeyboard = {
            setPreferredBehavior: function(behavior) {
                if (['auto', 'push', 'overlay'].indexOf(behavior) !== -1) {
                    config.preferredBehavior = behavior;
                    if (config.debug) console.log('Keyboard behavior set to: ' + behavior);
                    measureKeyboard(); // Re-measure immediately
                }
            },
            debug: function(enabled) {
                config.debug = !!enabled;
            }
        };
        
        // Initialize when document is ready
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            initialize();
        } else {
            window.addEventListener('DOMContentLoaded', initialize);
        }
      })();
    </script>
    <script>
      // Detecta quando o conteúdo WebGL está carregado
      document.addEventListener("DOMContentLoaded", function() {
          // Aguarda o UnityLoader ou UnityInstance estar pronto
          var trySelect = function() {
              var canvas = document.getElementById('canvas') || document.querySelector('canvas');
              if (canvas) {
                  if (typeof window.SelectWebGLCanvas === "function") {
                      window.SelectWebGLCanvas();
                  } else if (typeof window.Module !== "undefined" && Module.SelectWebGLCanvas) {
                      Module.SelectWebGLCanvas();
                  } else {
                      // Fallback direto
                      canvas.focus();
                      canvas.style.outline = "2px solid #00f";
                  }
              } else {
                  setTimeout(trySelect, 100);
              }
          };
          trySelect();
      });
    </script>
  </body>
</html>
